/*
 * Micro query processing framework for Terrier 5
 *
 * Copyright (C) 2018-2019 Nicola Tonellotto 
 *
 *  This library is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as published by the Free
 *  Software Foundation; either version 3 of the License, or (at your option)
 *  any later version.
 *
 *  This library is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package it.cnr.isti.hpclab.matching;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import it.cnr.isti.hpclab.matching.structures.Query;
import it.cnr.isti.hpclab.matching.structures.ResultSet;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import it.unimi.dsi.fastutil.objects.ObjectList;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.net.URL;
import java.util.Collections;
import java.util.Map.Entry;
import java.util.Properties;

import org.junit.ClassRule;
import org.junit.rules.TemporaryFolder;
import org.terrier.applications.BatchIndexing;
import org.terrier.applications.TRECIndexingSinglePass;
import org.terrier.structures.Index;
import org.terrier.structures.LexiconEntry;
import org.terrier.utility.ApplicationSetup;
import org.terrier.utility.Files;

/** 
 * Base class for a test that requires ApplicationSetup to be correctly initialised.
 * Uses a JUnit-created temporary folder, and invokes TRECSetup on it, to ensure that
 * a default configuration is generated.
 */
public abstract class MatchingSetupTest 
{
	@ClassRule
	public static TemporaryFolder tmpFolder = null;

	protected static String terrierHome;
	protected static String terrierEtc;
	
	public static void makeEnvironment() throws Exception
	{
		makeEnvironment(false);
	}
	
	/**
	 * Performs the following step:
	 * <ol>
	 * 	 <li> Creates a temporary folder where to store the test index.
	 * 	 <li> Creates a clean terrier.etc folder.
	 * 	 <li> Creates a terrier.properties file to index the test collection, with and wihtout blocks
	 * 	 <li> Creates a log configuration file.
	 * </ol>
	 * @param with_blocks if true, indexing will generate a positional index.
	 *
	 * @throws Exception
	 */
	public static void makeEnvironment(final boolean with_blocks) throws Exception
	{
		tmpFolder = new TemporaryFolder();
		tmpFolder.create();
		
		// Setting up terrier.home to user home folder
		terrierHome = System.getProperty("user.dir");
		System.setProperty("terrier.home", terrierHome);
		System.out.println("terrier.home = "+ terrierHome);
		
		// Setting up terrier.etc to a tmp directory
		terrierEtc = tmpFolder.getRoot().toString();
		System.setProperty("terrier.etc", terrierEtc);
		System.out.println("terrier.etc = "+ terrierEtc);
		
		// Cleaning up the contents of terrier.etc if it exists
		File fs[] = new File(terrierEtc).listFiles();
		if (fs != null)
			for (File f : fs)
				f.delete();
		// Creating terrierEtc
		new File(terrierEtc).mkdirs();

		
		System.setProperty("terrier.setup", terrierEtc + "/terrier.properties");
		createTerrierLogFile();
		createTerrierPropertiesFile(with_blocks);
		
		InputStream is = new FileInputStream(terrierEtc + "/terrier.properties");
		Properties prop = new Properties();
		prop.load(is);
		is.close();
		
		OutputStream os = new FileOutputStream(terrierEtc+ "/terrier.properties.test");
		prop.setProperty("terrier.index.path", terrierEtc);
		prop.setProperty("trec.results", terrierEtc);
		
		// addGlobalTerrierProperties(prop);
		prop.store(os, "#generated by " + MatchingSetupTest.class.getName());
		os.close();
		assertTrue(Files.delete(terrierEtc + "/terrier.properties"));
		assertTrue(Files.rename(terrierEtc+ "/terrier.properties.test", terrierEtc + "/terrier.properties"));		
		
		ApplicationSetup.bootstrapInitialisation();

		assertEquals(terrierHome, ApplicationSetup.TERRIER_HOME);
		assertEquals(terrierEtc,  ApplicationSetup.TERRIER_ETC);
		assertEquals(terrierEtc,  ApplicationSetup.TERRIER_INDEX_PATH);
		
		URL url = Query.class.getResource("/stopword-list.txt");
		System.setProperty("stopwords.filename", url.toString());
		System.setProperty("termpipelines", "Stopwords,PorterStemmer");		
	}
	
	/**
	 * Deletes the temporary folder an all its contents.
	 */
	public static void deleteTerrierEtc()
	{
		File fs[] = new File(terrierEtc).listFiles();
		if (fs != null)
			for (File f : fs)
				f.delete();
		ApplicationSetup.clearAllProperties();
		tmpFolder.delete();
	}

	/**
	 * Creates a log configuration file for testing purposes.
	 * 
	 * @throws IOException
	 */
	private static void createTerrierLogFile() throws IOException
	{
		// creating a terrier-log.xml file
		PrintWriter terrierlog = new PrintWriter(new FileWriter(terrierEtc + File.separator + "terrier-log.xml"));
		System.out.println("Creating logging configuration (terrier-log.xml) file.");
		terrierlog.println("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>");
		terrierlog.println("<!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\">");
		terrierlog.println("<log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\">");
		terrierlog.println(" <appender name=\"console\" class=\"org.apache.log4j.ConsoleAppender\">");
		terrierlog.println("  <param name=\"Target\" value=\"System.err\"/>");
		terrierlog.println("  <layout class=\"org.apache.log4j.SimpleLayout\"/>");
		terrierlog.println(" </appender>");
		terrierlog.println(" <root>");
		//if (debug)
			terrierlog.println("  <priority value=\"debug\" /><!-- Terrier: change debug to info to get less output -->");
		//else
		//	terrierlog.println("  <priority value=\"info\" /><!-- Terrier: change to debug to get more output -->");
		terrierlog.println("  <appender-ref ref=\"console\" />");
		terrierlog.println(" </root>");
		terrierlog.println("</log4j:configuration>");
		terrierlog.close();
		
		System.out.println("Terrier log file created: " + terrierEtc + File.separator + "terrier-log.xml");
		
		// creating a logback.xml file
		// actually this is useless, we need to put logback.xml file on classpath!!
		PrintWriter terrierlog2 = new PrintWriter(new FileWriter(terrierEtc + File.separator + "logback.xml"));
		System.out.println("Creating logging configuration (logback.xml) file.");
		
		terrierlog2.println("<configuration>");
		terrierlog2.println("  <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">");
		terrierlog2.println("      <!-- encoders are assigned the type");
		terrierlog2.println("                    ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->");
		terrierlog2.println("     <encoder>");
		terrierlog2.println("          <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>");
		terrierlog2.println("     </encoder>");
		terrierlog2.println("  </appender>");
		terrierlog2.println("  <root level=\"info\">");
		terrierlog2.println("      <appender-ref ref=\"STDOUT\" />");
		terrierlog2.println("  </root>");
		terrierlog2.println("</configuration>");
		terrierlog2.println("Creating logging configuration (terrier-log.xml) file.");
		terrierlog2.close();
		
		System.out.println("Terrier log file created: " + terrierEtc + File.separator + "logback.xml");

	}
	
	/**
	 * Creates a Terrier properties file for testing purposes.
	 * 
	 * @throws IOException
	 */

	private static void createTerrierPropertiesFile(final boolean with_blocks) throws IOException
	{
		//creating the terrier.properties file
		PrintWriter propertiesWriter = new PrintWriter(new FileWriter(terrierEtc + File.separator + "terrier.properties"));
		System.out.println("Creating terrier.properties file.");		
		propertiesWriter.println("#default controls for query expansion");
		propertiesWriter.println("querying.postprocesses.order=QueryExpansion");
		propertiesWriter.println("querying.postprocesses.controls=qe:QueryExpansion");
		propertiesWriter.println("#default controls for the web-based interface. SimpleDecorate");
		propertiesWriter.println("#is the simplest metadata decorator. For more control, see Decorate.");
		propertiesWriter.println("querying.postfilters.order=SimpleDecorate,SiteFilter,Scope");
		propertiesWriter.println("querying.postfilters.controls=decorate:SimpleDecorate,site:SiteFilter,scope:Scope");
		propertiesWriter.println();
		propertiesWriter.println("#default and allowed controls");
		propertiesWriter.println("querying.default.controls=");
		propertiesWriter.println("querying.allowed.controls=scope,qe,qemodel,start,end,site,scope");
		propertiesWriter.println();
		propertiesWriter.println("#document tags specification");
		propertiesWriter.println("#for processing the contents of");
		propertiesWriter.println("#the documents, ignoring DOCHDR");
		propertiesWriter.println("TrecDocTags.doctag=DOC");
		propertiesWriter.println("TrecDocTags.idtag=DOCNO");
		propertiesWriter.println("TrecDocTags.skip=DOCHDR");
		propertiesWriter.println("#set to true if the tags can be of various case");
		propertiesWriter.println("TrecDocTags.casesensitive=false");

		propertiesWriter.println();
		propertiesWriter.println("#query tags specification");
		propertiesWriter.println("TrecQueryTags.doctag=TOP");
		propertiesWriter.println("TrecQueryTags.idtag=NUM");
		propertiesWriter.println("TrecQueryTags.process=TOP,NUM,TITLE");
		propertiesWriter.println("TrecQueryTags.skip=DESC,NARR");
		propertiesWriter.println();
		propertiesWriter.println("#stop-words file");
		propertiesWriter.println("stopwords.filename=stopword-list.txt");
		propertiesWriter.println();
		propertiesWriter.println("#the processing stages a term goes through");
		propertiesWriter.println("termpipelines=Stopwords,PorterStemmer");
		propertiesWriter.println();
		
	    if (with_blocks) {
	    	propertiesWriter.println("#indexing with blocks, minimum properties:");
	    	propertiesWriter.println("block.indexing=true");
	    	propertiesWriter.println("blocks.max=" + Integer.toString(Integer.MAX_VALUE));
	    	propertiesWriter.println();
	    }
		
		propertiesWriter.close();
		
		System.out.println("Terrier properties file created: " + terrierEtc + File.separator + "terrier.properties");
	}
	
	public static void doWT10GSampleIndexing(String suffix) throws Exception
	{
		makeCollectionSpec(new PrintWriter(Files.writeFileWriter(terrierEtc +  "/collection.spec")));
		doIndexing(suffix);
	}

	public static void doWT10GSampleIndexing() throws Exception
	{
		makeCollectionSpec(new PrintWriter(Files.writeFileWriter(terrierEtc +  "/collection.spec")));
		doIndexing();
	}

	protected static void doShakespeareIndexing() throws Exception
	{
		makeShakespeareCollectionSpec(new PrintWriter(Files.writeFileWriter(terrierEtc +  "/collection.spec")));
		doIndexing();
	}
	
	protected static void makeShakespeareCollectionSpec(PrintWriter p) throws Exception 
	{
		p.println(System.getProperty("user.dir") + "/src/test/resources/shakespeare/shakespeare-merchant.trec.1");
		p.println(System.getProperty("user.dir") + "/src/test/resources/shakespeare/shakespeare-merchant.trec.2");
		p.close();
	}
	
	protected static void makeCollectionSpec(PrintWriter p) throws Exception 
	{
		p.println(System.getProperty("user.dir") + "/src/test/resources/wt10g/B01.gz");
		p.println(System.getProperty("user.dir") + "/src/test/resources/wt10g/B02.gz");
		p.println(System.getProperty("user.dir") + "/src/test/resources/wt10g/B03.gz");
		p.println(System.getProperty("user.dir") + "/src/test/resources/wt10g/B04.gz");
		p.close();
	}

	protected static void doIndexing() throws Exception
	{
		doIndexing("");
	}	

	protected static void doIndexing(String suffix) throws Exception
	{
		String path = terrierEtc;
		String prefix = "data" + suffix;
	
		ApplicationSetup.TERRIER_INDEX_PATH = path;
		ApplicationSetup.TERRIER_INDEX_PREFIX = prefix;
				
		BatchIndexing indexing = new TRECIndexingSinglePass(ApplicationSetup.TERRIER_INDEX_PATH, ApplicationSetup.TERRIER_INDEX_PREFIX);
		indexing.index();			

		// TrecTerrier.main(new String[] {"-i", "-j"});
				
		// check that indexing actually created an index
		assertTrue("Index does not exist at [" + path + "," + prefix + "]", Index.existsIndex(path, prefix));
		
		Index i = Index.createIndex();
		assertNotNull(Index.getLastIndexLoadError(), i);
		assertTrue("Index does not have an inverted structure", i.hasIndexStructure("inverted"));
		assertTrue("Index does not have an lexicon structure", i.hasIndexStructure("lexicon"));
		assertTrue("Index does not have an document structure", i.hasIndexStructure("document"));
		assertTrue("Index does not have an meta structure", i.hasIndexStructure("meta"));
		i.close();
	}	

	public static void Compare(ResultSet correct, ResultSet current)
	{
		int[]    correctDocids = correct.docids();
		float[] correctScores = correct.scores();

		int[]   docids = current.docids();
		float[] scores = current.scores();
		
		// Rouding up scores to avoid no-errors due to 6th decimal value
		for (int i = 0; i < correctScores.length; i++) {
			BigDecimal bd = new BigDecimal(correctScores[i]).setScale(4, RoundingMode.FLOOR);
			correctScores[i] = bd.floatValue();
		}

		for (int i = 0; i < scores.length; i++) {
			BigDecimal bd = new BigDecimal(scores[i]).setScale(4, RoundingMode.FLOOR);
			scores[i] = bd.floatValue();
		}

		// assertEquals(correct.size(), current.size());
		
		ObjectList<Tuple> correct_tuples = new ObjectArrayList<Tuple>();
		ObjectList<Tuple> tuples = new ObjectArrayList<Tuple>();
		for (int i = 0; i < correct.size(); ++i) {
			correct_tuples.add(new Tuple(correctDocids[i], correctScores[i]));
			tuples.add(new Tuple(docids[i], scores[i]));
		}
		
		Collections.sort(correct_tuples);
		Collections.sort(tuples);
		
		// The last subsets might not contain correct docids if the result set has been resized
		float correct_last_score = correct_tuples.get(correct_tuples.size() - 1).score;
		float last_score = correct_tuples.get(tuples.size() - 1).score;
		
		for (Tuple t: correct_tuples)
			if (t.score == correct_last_score)
				t.docid = -1;

		for (Tuple t: tuples)
			if (t.score == last_score)
				t.docid = -1;

		for (int i = 0; i < correct.size(); ++i) {
			assertEquals(correct_tuples.get(i).docid, tuples.get(i).docid);
			assertEquals(correct_tuples.get(i).score, tuples.get(i).score, 1e-3);
		}
	}
	
	public static void main(String[] args) throws Exception
	{
		makeEnvironment();
		doWT10GSampleIndexing();
		
		Index index = Index.createIndex();
		
		int num_terms = index.getCollectionStatistics().getNumberOfUniqueTerms();
		//System.err.println(num_terms);
		for (int i = 0 ; i < num_terms; i++) {
			Entry<String, LexiconEntry> e = index.getLexicon().getIthLexiconEntry(i);
			if (e.getValue().getDocumentFrequency() >= 10 && e.getValue().getDocumentFrequency() <= 50) {
				System.err.println(e.getKey() + "\t" + e.getValue());
			}
		}
		deleteTerrierEtc();
	}

	final public static class Tuple implements Comparable<Tuple>
	{
	    public int docid;
	    public float score;

	    public Tuple(int docid, float score) {
	        this.docid = docid;
	        this.score = score;
	    }

	    public int compareTo(Tuple other) 
	    {
	    	if ( Float.compare(this.score,  other.score) != 0)
	    		return -Float.compare(this.score,  other.score);
	    	return Integer.compare(this.docid,  other.docid);
	    }
	    
	    public String toString()
	    {
	    	return docid + " " + score;
	    }
	}
}
